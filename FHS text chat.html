<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>P2P Chat v0.5 — single file</title>
<style>
  :root{
    --w:512px; --h:800px; --gap:.5rem; --pane-bg:#000; --ink:#eaeaea; --muted:#a7a7a7;
    --accent:#9b87f5; --ok:#10b981; --warn:#f59e0b; --err:#ef4444; --bg:#0a0a0a;
  }
  html,body{height:100%;}
  body{margin:0; background:#111; color:var(--ink); font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; display:grid; place-items:center;}
  /* App shell */
  .app{width:var(--w); height:var(--h); background:var(--pane-bg); position:relative; box-shadow:0 8px 40px rgba(0,0,0,.5); border:1px solid #222; overflow:hidden;}
  header{display:flex; align-items:center; justify-content:space-between; padding:.6rem .8rem; background:#0f0f0f; border-bottom:1px solid #1c1c1c;}
  header .title{font-weight:700; letter-spacing:.2px;}
  header .version{font-size:.8rem; color:var(--muted)}
  .row{display:flex; gap:.4rem; align-items:center;}
  select, input[type=text], button, .chip{background:#121212; color:var(--ink); border:1px solid #2b2b2b; border-radius:.45rem; padding:.45rem .55rem;}
  input[type=text]{width:150px;}
  button{cursor:pointer}
  button:disabled{opacity:.5; cursor:not-allowed}
  .pill{padding:.3rem .5rem; border-radius:999px; font-size:.75rem;}
  .muted{color:var(--muted)}
  .hint{font-size:.75rem; color:#c9c9c9}

  /* Canvas area */
  .stage{position:relative; width:100%; aspect-ratio:1/1; background:#000;}
  .stage-inner{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:420px; height:420px;}
  .mirror{position:absolute; inset:0; display:grid; place-items:center;}
  .mirror img{width:100%; height:100%; object-fit:cover; border-radius:.2rem;}
  .frame{position:absolute; inset:0; pointer-events:none;}
  .frame img{width:100%; height:100%; object-fit:contain; filter:drop-shadow(0 2px 10px rgba(0,0,0,.6));}
  .frameHotspot{position:absolute; inset:0; cursor:pointer;}

  /* Dock under the frame (client reactions) */
  .dock{display:none; gap:.5rem; align-items:center; padding:.6rem .7rem; border-top:1px solid #1f1f1f; background:#0c0c0c;}
  .dock.show{display:flex}
  .colors{display:flex; gap:.25rem}
  .sw{width:16px; height:16px; border-radius:3px; border:1px solid #2b2b2b; cursor:pointer; outline:1px solid transparent}
  .sw.sel{outline:1px solid #fff}
  .toast{position:absolute; left:50%; top:6px; transform:translateX(-50%); background:#0d0d0d; padding:.5rem .7rem; border:2px solid #444; border-radius:.6rem; box-shadow:0 6px 30px rgba(0,0,0,.55); opacity:0; transition:opacity .2s ease}
  .toast.show{opacity:1}

  /* Connection panel */
  .connect{display:grid; grid-template-columns:1fr; gap:.5rem; padding:.6rem .8rem; border-bottom:1px solid #1c1c1c;}
  .connect .row{flex-wrap:wrap}
  .codebox{font-weight:700; letter-spacing:.05em; padding:.2rem .45rem; border:1px dashed #3a3a3a; border-radius:.35rem}
  .status{font-size:.9rem; color:#c9c9c9}

  /* Chat area */
  .chat{display:grid; grid-template-rows:auto 1fr; height:calc(100% - 420px - 136px);}
  .chatHeader{display:flex; justify-content:space-between; align-items:center; padding:.4rem .6rem; border-top:1px solid #1c1c1c;}
  .cols{display:grid; grid-template-columns:1fr 1fr; gap:.4rem; padding:.3rem .6rem .6rem; overflow:auto}
  .col{border:1px solid #1e1e1e; border-radius:.5rem; padding:.35rem; min-height:80px}
  .nick{font-size:.8rem; color:#a9a9a9; margin-bottom:.2rem; display:flex; justify-content:space-between;}
  .bubble{background:#141414; border:1px solid #242424; padding:.35rem .45rem; border-radius:.45rem; margin:.3rem 0;}
  .bubble.me{border-color:#2d3f8f}
  .bubble.peer{border-color:#2d8f3f}
  .chatInput{display:flex; gap:.4rem; padding:.5rem .6rem; border-top:1px solid #1c1c1c;}
  .history{display:none; padding:.5rem .6rem; border-top:1px dashed #303030; max-height:140px; overflow:auto}
  .history.show{display:block}

  .foot{position:absolute; bottom:.4rem; right:.6rem; font-size:.75rem; color:#8a8a8a}

  /* Accessibility helpers */
  [role=button]{cursor:pointer}
</style>
</head>
<body>
<div class="app" aria-label="P2P chat app">
  <header>
    <div class="title">P2P Chat — <span class="version">v0.5</span></div>
    <div class="row">
      <label class="muted" for="roleSel">Ruolo</label>
      <select id="roleSel" title="Seleziona ruolo">
        <option value="server">SERVER</option>
        <option value="client">CLIENT</option>
      </select>
      <span class="pill" id="status" aria-live="polite">offline</span>
    </div>
  </header>

  <!-- Connection controls -->
  <section class="connect" aria-label="Connessione">
    <div class="row">
      <button id="createBtn">Crea chat</button>
      <input id="joinCode" type="text" inputmode="verbatim" placeholder="Inserisci codice" maxlength="24">
      <button id="joinBtn">Entra</button>
      <span class="codebox" id="codeBox">—</span>
    </div>
    <div class="row">
      <input id="inviteLink" type="text" readonly placeholder="Link invito" style="width:100%">
      <button id="copyBtn" title="Copia link invito">Copia</button>
    </div>
    <div class="status" id="connHint">Stato: in attesa</div>
  </section>

  <!-- Square stage with frame/mirror -->
  <section class="stage" aria-label="Specchio e cornice">
    <div class="stage-inner">
      <div class="mirror" id="mirrorBox" aria-live="polite">
        <img id="mirror" alt="Immagine nello specchio" src=""/>
      </div>
      <div class="frame">
        <img alt="Cornice" id="frameImg" src=""/>
      </div>
      <div class="frameHotspot" id="frameHotspot" title="Clic per cambiare immagine (solo SERVER)"></div>
      <div class="toast" id="toast">reazione</div>
    </div>
  </section>

  <!-- Reaction dock (client only, appears when a new image arrives) -->
  <div class="dock" id="dock" aria-label="Reazione all'immagine">
    <label for="reactionSel" class="muted">Feedback</label>
    <select id="reactionSel" title="Scegli reazione">
      <option>AIUTO!</option>
      <option>BELLISSIMA</option>
      <option>NE' CALDO NE' FREDDO</option>
      <option>NORMALE</option>
      <option>DA BRIVIDI!</option>
      <option>NO GRAZIE</option>
      <option>PAURA!</option>
      <option>SORPRESA!</option>
      <option>IMBARAZZO</option>
    </select>
    <span class="muted">Intensità</span>
    <div class="colors" id="colors"></div>
    <button id="sendReact">Invia</button>
  </div>

  <!-- Chat -->
  <section class="chat" aria-label="Chat">
    <div class="chatHeader">
      <div class="row">
        <label class="muted" for="nickMe">Nickname</label>
        <input id="nickMe" type="text" placeholder="Il tuo nome" value="Anon">
        <label class="muted" for="nickPeer">Peer</label>
        <input id="nickPeer" type="text" placeholder="Nome peer" value="Peer">
      </div>
      <div class="row">
        <button id="toggleHist" class="chip">STORIA</button>
      </div>
    </div>
    <div class="cols">
      <div class="col" id="colMe">
        <div class="nick"><span id="nickMeLbl">Me</span><span class="muted">ultimi 3</span></div>
        <div class="stack" id="meStack"></div>
      </div>
      <div class="col" id="colPeer">
        <div class="nick"><span id="nickPeerLbl">Peer</span><span class="muted">ultimi 3</span></div>
        <div class="stack" id="peerStack"></div>
      </div>
    </div>
    <div class="history" id="history"></div>
    <div class="chatInput">
      <input id="text" type="text" placeholder="Scrivi…">
      <button id="sendBtn" disabled>Invia</button>
    </div>
  </section>

  <div class="foot">STUN: stun.l.google.com:19302 · signaling: ntfy.sh</div>

  <input type="file" id="filePicker" accept="image/*" hidden>
</div>

<script>
(() => {
  const VERSION = 'v0.5';
  const STUNS = [{ urls: 'stun:stun.l.google.com:19302' }];
  const SIGNAL_BASE = 'https://ntfy.sh';
  const colors = ['#d7d7d7','#c6c1d4','#aea7dc','#958eef','#7d73f3','#6557e6','#800080'];
  const $ = (id) => document.getElementById(id);

  const state = {
    role: 'server',
    pc: null, dc: null, sse: null,
    roomCode: null, isOfferer: false,
    selfId: crypto.getRandomValues(new Uint32Array(1))[0].toString(16),
    sendingImage: false,
    recv: null, // {id,size,type,got,buffers:[]}
    history: [], meMsgs: [], peerMsgs: []
  };

  // Frame (with cache-busting)
  const frameUrl = `https://massimagnus.github.io/FHS-chat/cornice.png?v=${encodeURIComponent(VERSION)}`;
  $('frameImg').src = frameUrl;

  // Role selection
  $('roleSel').addEventListener('change', (e) => {
    state.role = e.target.value;
    // Only server can change image; hint cursor accordingly
    $('frameHotspot').style.cursor = state.role === 'server' ? 'pointer' : 'not-allowed';
  });

  // Connection helpers
  function setStatus(t){ $('status').textContent = t; }
  function topic(code){ return `p2pchat-${code}`; }
  function genCode(){ return 'P2P-' + Math.random().toString(36).slice(2,7).toUpperCase(); }
  function currentBaseURL(){ const u=new URL(location.href); return `${u.origin}${u.pathname}`; }
  function makeInviteLink(code){ const u=new URL(currentBaseURL()); u.searchParams.set('code',code); u.searchParams.set('join','1'); return u.toString(); }

  // UI bits
  const meStack = $('meStack');
  const peerStack = $('peerStack');
  const historyEl = $('history');
  const mirror = $('mirror');
  const dock = $('dock');
  const toast = $('toast');

  function pushMsg(kind, text){
    const time = new Date().toLocaleTimeString();
    state.history.unshift({time, who:kind, text}); // newest first
    if (kind === 'me'){ state.meMsgs.unshift({time,text}); trimStacks(); renderStacks(); }
    else if (kind === 'peer'){ state.peerMsgs.unshift({time,text}); trimStacks(); renderStacks(); }
    renderHistory();
  }
  function trimStacks(){ state.meMsgs = state.meMsgs.slice(0,3); state.peerMsgs = state.peerMsgs.slice(0,3); }
  function bubble(html, cls){ const d=document.createElement('div'); d.className = `bubble ${cls}`; d.innerHTML = html; return d; }
  function renderStacks(){
    meStack.innerHTML = ''; peerStack.innerHTML='';
    state.meMsgs.forEach(m => meStack.appendChild(bubble(`<div>${escapeHtml(m.text)}</div><div class="hint">${m.time}</div>`, 'me')));
    state.peerMsgs.forEach(m => peerStack.appendChild(bubble(`<div>${escapeHtml(m.text)}</div><div class="hint">${m.time}</div>`, 'peer')));
  }
  function renderHistory(){ historyEl.innerHTML = state.history.map(e => `<div class="hint">[${e.time}] <b>${e.who}</b> — ${escapeHtml(e.text)}</div>`).join(''); }
  function escapeHtml(s){ return s.replace(/[&<>\"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\\':'\\'}[c])); }

  // Reaction dock colors
  (function initColors(){
    const cWrap = $('colors');
    colors.forEach((c,idx) => {
      const sw = document.createElement('div'); sw.className='sw'; sw.style.background=c; sw.setAttribute('data-i',String(idx));
      sw.addEventListener('click', () => {
        [...cWrap.children].forEach(x=>x.classList.remove('sel')); sw.classList.add('sel'); cWrap.setAttribute('data-sel', String(idx));
      });
      if(idx===0){ sw.classList.add('sel'); cWrap.setAttribute('data-sel','0'); }
      cWrap.appendChild(sw);
    });
  })();

  // STAGE interactions
  const picker = $('filePicker');
  $('frameHotspot').addEventListener('click', () => {
    if (state.role !== 'server') { flashToast("Solo il SERVER può cambiare lo specchio", '#3a3a3a'); return; }
    if (!state.dc || state.dc.readyState !== 'open'){ flashToast('Non connesso', '#444'); return; }
    picker.click();
  });
  picker.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0]; if(!f) return;
    await sendImage(f);
  });

  // Toast
  let toastTimer=null; function flashToast(msg, color){
    toast.textContent = msg; toast.style.borderColor = color || '#444'; toast.classList.add('show');
    clearTimeout(toastTimer); toastTimer = setTimeout(()=> toast.classList.remove('show'), 6000);
  }

  // Reaction sending (client)
  $('sendReact').addEventListener('click', () => {
    if (!state.dc || state.dc.readyState !== 'open') return;
    const tag = $('reactionSel').value; const idx = Number($('colors').getAttribute('data-sel')||'0');
    sendJson({t:'reaction', tag, idx});
  });

  // Chat
  $('sendBtn').addEventListener('click', () => {
    const t = $('text').value.trim(); if(!t || !state.dc || state.dc.readyState!=='open') return;
    state.dc.send(t); pushMsg('me', t); $('text').value='';
  });
  $('text').addEventListener('keydown', e => { if(e.key==='Enter') $('sendBtn').click(); });
  $('toggleHist').addEventListener('click', () => { historyEl.classList.toggle('show'); });
  $('nickMe').addEventListener('input', () => { $('nickMeLbl').textContent = $('nickMe').value || 'Me'; });
  $('nickPeer').addEventListener('input', () => { $('nickPeerLbl').textContent = $('nickPeer').value || 'Peer'; });

  // Connect buttons
  $('createBtn').addEventListener('click', async () => { await createRoom(); });
  $('joinBtn').addEventListener('click', async () => {
    const code = $('joinCode').value.trim().toUpperCase(); if (!code) return;
    await joinRoom(code);
  });
  $('copyBtn').addEventListener('click', async () => {
    if(!$('inviteLink').value) return;
    try{ await navigator.clipboard.writeText($('inviteLink').value); flashToast('Link copiato', '#3355ff'); }catch{ flashToast('Copia non riuscita', '#444'); }
  });

  // WebRTC
  async function createRoom(){
    state.roomCode = genCode(); $('codeBox').textContent = state.roomCode; state.isOfferer = true;
    const link = makeInviteLink(state.roomCode); $('inviteLink').value = link; $('connHint').textContent = 'Condividi il link invito con il peer.';
    await start();
  }
  async function joinRoom(code){
    state.roomCode = code; $('codeBox').textContent = code; state.isOfferer = false;
    $('inviteLink').value = makeInviteLink(code); $('connHint').textContent = 'Entrato nella stanza. Attendo handshake…';
    await start();
  }

  async function start(){
    setStatus('preparazione…');
    setupPeer();
    subscribeSSE(topic(state.roomCode));
    if (state.isOfferer){
      const offer = await state.pc.createOffer();
      await state.pc.setLocalDescription(offer);
      await publish({ t:'offer', sdp: state.pc.localDescription });
    }
    setStatus('in attesa handshake…');
  }

  function setupPeer(){
    state.pc = new RTCPeerConnection({ iceServers: STUNS });
    if (state.isOfferer){
      state.dc = state.pc.createDataChannel('chat');
      wireDC(state.dc);
    } else {
      state.pc.ondatachannel = (ev) => { state.dc = ev.channel; wireDC(state.dc); };
    }
    state.pc.onicecandidate = (ev) => { if (ev.candidate) publish({ t:'candidate', candidate: ev.candidate }); };
    state.pc.onconnectionstatechange = () => {
      const cs = state.pc.connectionState;
      if (cs === 'connected'){ setStatus('P2P connesso'); $('sendBtn').disabled=false; flashToast('Chat pronta', '#2a7'); }
      else if (cs === 'failed' || cs === 'disconnected'){ setStatus('connessione persa'); $('sendBtn').disabled=true; }
    };
  }

  function wireDC(ch){
    ch.binaryType = 'arraybuffer';
    ch.onopen = () => { pushMsg('system', 'Canale aperto'); };
    ch.onclose = () => { pushMsg('system', 'Canale chiuso'); };
    ch.onmessage = (ev) => {
      if (typeof ev.data === 'string') handleText(ev.data); else handleBinary(ev.data);
    };
  }

  async function handleText(s){
    try{
      const msg = JSON.parse(s);
      if (msg.t === 'offer' || msg.t === 'answer' || msg.t === 'candidate'){ /* signaling arrives via SSE only */ return; }
      if (msg.t === 'reaction'){
        const color = colors[(msg.idx|0) % colors.length];
        flashToast(`reazione: ${msg.tag}`, color);
        return;
      }
      if (msg.t === 'image-begin'){
        state.recv = { id: msg.id, size: msg.size|0, type: msg.type||'image/jpeg', got:0, buffers:[] };
        if (state.role === 'client') dock.classList.add('show');
        return;
      }
    }catch{ /* Not JSON: treat as chat */ }
    // Plain chat text
    pushMsg('peer', s);
  }

  function handleBinary(buf){
    if (!state.recv) return; // unexpected
    state.recv.buffers.push(buf); state.recv.got += buf.byteLength;
    if (state.recv.got >= state.recv.size){
      const blob = new Blob(state.recv.buffers, {type: state.recv.type});
      const url = URL.createObjectURL(blob);
      mirror.src = url;
      state.recv = null;
    }
  }

  // Signaling via ntfy.sh (SSE subscribe + POST publish)
  let sse; function subscribeSSE(tpc){
    if (sse) sse.close();
    sse = new EventSource(`${SIGNAL_BASE}/${tpc}/sse`);
    sse.onopen = () => { $('connHint').textContent = 'Collegato al signaling.'; };
    sse.onerror = () => { $('connHint').textContent = 'Errore signaling (ritento)…'; };
    sse.onmessage = async (ev) => {
      try{
        const envelope = JSON.parse(ev.data);
        if (!envelope || typeof envelope.message !== 'string') return;
        const msg = JSON.parse(envelope.message);
        if (!msg || msg.from === state.selfId) return;
        await handleSignal(msg);
      }catch{ /* ignore */ }
    };
  }
  async function publish(obj){
    if (!state.roomCode) return;
    const body = JSON.stringify({ ...obj, from: state.selfId });
    try{ await fetch(`${SIGNAL_BASE}/${topic(state.roomCode)}`, { method:'POST', body }); }catch{}
  }
  async function handleSignal(msg){
    if (msg.t === 'offer'){
      await state.pc.setRemoteDescription(msg.sdp);
      const answer = await state.pc.createAnswer();
      await state.pc.setLocalDescription(answer);
      await publish({ t:'answer', sdp: state.pc.localDescription });
    } else if (msg.t === 'answer'){
      await state.pc.setRemoteDescription(msg.sdp);
    } else if (msg.t === 'candidate'){
      try{ await state.pc.addIceCandidate(msg.candidate); }catch{}
    }
  }

  // Image sending with simple chunking (sequential transfer)
  async function sendImage(file){
    if (state.sendingImage) { flashToast('Trasferimento in corso…', '#444'); return; }
    if (!state.dc || state.dc.readyState !== 'open') { flashToast('Canale non aperto', '#444'); return; }
    const ab = await file.arrayBuffer();
    const id = Math.random().toString(36).slice(2);
    sendJson({ t:'image-begin', id, size: ab.byteLength, type: file.type || 'image/jpeg' });
    state.sendingImage = true;
    const CHUNK = 60 * 1024; // 60KB chunks
    for (let off=0; off<ab.byteLength; off+=CHUNK){
      const slice = ab.slice(off, Math.min(off+CHUNK, ab.byteLength));
      state.dc.send(slice);
      await wait(2); // yield to avoid congestion
    }
    state.sendingImage = false;
    flashToast('Immagine inviata', '#2a7');
    // show locally too
    mirror.src = URL.createObjectURL(new Blob([ab],{type:file.type}));
  }
  function sendJson(o){ state.dc && state.dc.readyState==='open' && state.dc.send(JSON.stringify(o)); }
  function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // Auto join from URL
  (function autoJoin(){
    const url = new URL(location.href);
    const code = (url.searchParams.get('code')||'').trim().toUpperCase();
    const join = url.searchParams.get('join') === '1';
    if (code){ $('joinCode').value = code; if (join){ state.isOfferer=false; state.roomCode=code; $('codeBox').textContent=code; start(); } }
  })();
})();
</script>
</body>
</html>
