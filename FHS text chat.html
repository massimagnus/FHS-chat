<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>P2P Chat — 1 file</title>
  <style>
    :root { --gap:.6rem; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; max-width: 720px; margin: 2rem auto; padding: 0 1rem; }
    header { display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem; }
    h1 { font-size:1.1rem; margin:0; }
    .row { display:flex; gap:var(--gap); margin-bottom:var(--gap); }
    input[type=text]{ flex:1; padding:.6rem .7rem; border:1px solid #d0d7de; border-radius:.5rem; }
    button{ padding:.6rem 1rem; border:1px solid #d0d7de; background:#fff; border-radius:.5rem; cursor:pointer; }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    #codeBox{ font-weight:700; letter-spacing:.08em; padding:.2rem .5rem; border:1px dashed #ccd; border-radius:.4rem; }
    #status{ color:#555; font-size:.95rem; }
    #log{ height:320px; border:1px solid #e5e7eb; border-radius:.5rem; padding:.5rem; overflow:auto; background:#fafafa; }
    .msg{ padding:.2rem 0; }
    .msg.me{ text-align:right; }
    .msg.peer{ text-align:left; }
    .system{ color:#666; font-size:.9rem; }
    footer{ margin-top:1rem; color:#6b7280; font-size:.85rem; }
  </style>
</head>
<body>
  <header>
    <h1>P2P Chat (nessuna installazione)</h1>
    <div>Codice: <span id="codeBox">—</span></div>
  </header>

  <div class="row">
    <button id="createBtn">Crea chat</button>
    <input id="joinCode" type="text" placeholder="Inserisci codice" maxlength="24">
    <button id="joinBtn">Entra</button>
  </div>

  <div id="status">Stato: offline</div>
  <div id="log" aria-live="polite" aria-label="Messaggi della chat"></div>

  <div class="row">
    <input id="text" type="text" placeholder="Scrivi un messaggio…">
    <button id="sendBtn" disabled>Invia</button>
  </div>

  <footer>Browser↔Browser via WebRTC DataChannel. Il signaling usa un topic temporaneo pubblico su ntfy.sh.</footer>

<script>
/* ======== CONFIG ======== */
const STUNS = [{ urls: 'stun:stun.l.google.com:19302' }]; // Aggiungi TURN in produzione
const SIGNAL_BASE = 'https://ntfy.sh'; // broker pubblico per il solo signaling

/* ======== STATE ======== */
let pc, dc, roomCode = null, isOfferer = false;
const selfId = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);
const $ = (id) => document.getElementById(id);
const logEl = $('log');

function logSys(t){ append('system', t); }
function logMsg(w,t){ append('msg '+w, t); }
function append(cls, text){
  const d=document.createElement('div'); d.className=cls; d.textContent=text;
  logEl.appendChild(d); logEl.scrollTop = logEl.scrollHeight;
}
function setStatus(s){ $('status').textContent='Stato: '+s; }
function setSendEnabled(en){ $('sendBtn').disabled = !en; }

/* ======== UI ======== */
$('createBtn').onclick = async () => {
  roomCode = genCode(); $('codeBox').textContent = roomCode; isOfferer = true;
  await start(roomCode);
  logSys('Condividi il codice e attendi il peer.');
};
$('joinBtn').onclick = async () => {
  const code = $('joinCode').value.trim().toUpperCase();
  if (!code) return;
  roomCode = code; $('codeBox').textContent = code; isOfferer = false;
  await start(roomCode);
};

$('sendBtn').onclick = () => {
  const text = $('text').value;
  if (!text || !dc || dc.readyState !== 'open') return;
  dc.send(text); logMsg('me', text); $('text').value='';
};
$('text').addEventListener('keydown', e => { if (e.key === 'Enter') $('sendBtn').click(); });

/* ======== CORE ======== */
function genCode(){
  const s = Math.random().toString(36).slice(2,7).toUpperCase();
  return 'P2P-' + s;
}
function topic(code){ return `p2pchat-${code}`; }

async function start(code){
  setStatus('preparazione…');
  setupPeer();
  // subscribe to signaling stream (SSE)
  subscribeSSE(topic(code));
  // only the offerer triggers negotiation
  if (isOfferer) {
    // in some browsers, createOffer should follow onnegotiationneeded
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await publish({ t:'offer', sdp: pc.localDescription });
  }
  setStatus('in attesa handshake…');
}

function setupPeer(){
  pc = new RTCPeerConnection({ iceServers: STUNS });

  if (isOfferer) {
    dc = pc.createDataChannel('chat');
    wireDC(dc);
  } else {
    pc.ondatachannel = (ev) => { dc = ev.channel; wireDC(dc); };
  }

  pc.onicecandidate = (ev) => {
    if (ev.candidate) publish({ t:'candidate', candidate: ev.candidate });
  };

  pc.onconnectionstatechange = () => {
    if (pc.connectionState === 'connected'){ setStatus('P2P connesso'); setSendEnabled(true); logSys('Chat pronta.'); }
    else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed'){ setStatus('connessione persa'); setSendEnabled(false); }
  };
}

function wireDC(ch){
  ch.onopen  = () => { logSys('Canale aperto'); setSendEnabled(true); };
  ch.onclose = () => { logSys('Canale chiuso'); setSendEnabled(false); };
  ch.onmessage = (ev) => logMsg('peer', ev.data);
}

/* ======== SIGNALLING via ntfy.sh (SSE + POST) ======== */
let sse;
function subscribeSSE(tpc){
  if (sse) sse.close();
  // SSE endpoint
  sse = new EventSource(`${SIGNAL_BASE}/${tpc}/sse`);
  sse.onopen = () => logSys('Collegato al signaling');
  sse.onerror = () => logSys('Errore signaling (ritento se necessario)');

  sse.onmessage = async (ev) => {
    try {
      const envelope = JSON.parse(ev.data); // metadati ntfy
      // Il payload reale è in envelope.message (stringa)
      if (!envelope || typeof envelope.message !== 'string') return;
      const msg = JSON.parse(envelope.message);
      if (!msg || msg.from === selfId) return; // ignora i propri
      await handleSignal(msg);
    } catch { /* noop */ }
  };
}

async function publish(obj){
  if (!roomCode) return;
  const body = JSON.stringify({ ...obj, from: selfId });
  await fetch(`${SIGNAL_BASE}/${topic(roomCode)}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body
  }).catch(()=>{});
}

async function handleSignal(msg){
  if (msg.t === 'offer') {
    await pc.setRemoteDescription(msg.sdp);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    await publish({ t:'answer', sdp: pc.localDescription });
  } else if (msg.t === 'answer') {
    await pc.setRemoteDescription(msg.sdp);
  } else if (msg.t === 'candidate') {
    try { await pc.addIceCandidate(msg.candidate); } catch {}
  }
}
</script>
</body>
</html>
